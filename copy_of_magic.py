# -*- coding: utf-8 -*-
"""Copy of Magic

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1amNql1dYE5ZajM4Vd-pTFVWv3p0glTKv

#Magic Commands
"""

# Commented out IPython magic to ensure Python compatibility.
# %magic

# Commented out IPython magic to ensure Python compatibility.
# %timeit a=1
#line magic
print(a)

# Commented out IPython magic to ensure Python compatibility.
# #cell magic
# %%timeit 
# a=1
# b=a

print(a)

"""# Debugging"""

# Commented out IPython magic to ensure Python compatibility.
# %pdb
#automatic debug

def eval_func (f, x):
    return f(x)

def func (x):
    return 1 / x**0.5

eval_func(func, 0)

# Commented out IPython magic to ensure Python compatibility.
# %debug

import pdb
def permfinder(a):
  pdb.set_trace()
  if len(a)==1:
      perms=[a]
  else:
      perms=[]
      for i in range(len(a)):
        perms_i_last=permfinder(a[:i]+a[i+1:])
        for x in  perms_i_last:
          x.append(a[i])
        perms=perms+perms_i_last
  return perms

a=[1,2,3,4]
perms=permfinder(a)
print(perms)

"""#Profiling"""

import math
import pdb

# Commented out IPython magic to ensure Python compatibility.
# %%prun
# def comp_element(i, j):
#     return math.sqrt(i) + math.sqrt(j)
# 
# s = 0
# for i in range(1000): 
#     for j in reversed(range(1000)):
#         s += comp_element(i, j)
# print(s)

pip install line_profiler



import math
def comp_series(n):
    s = 0
    for i in range(n): 
        for j in reversed(range(n)):
            r = i**0.5 + j**0.5
            s += r
    return s

# Commented out IPython magic to ensure Python compatibility.
# %load_ext line_profiler
# %lprun -f comp_series comp_series(4000)

def factorial(n):
  if n==1:
    return 1
  return n*factorial(n-1)

# Commented out IPython magic to ensure Python compatibility.
# %lprun -f factorial factorial(10)

def Fib(n):
  if n==0 or n==1:
    return 1
  return Fib(n-1)+Fib(n-2)

# Commented out IPython magic to ensure Python compatibility.
# %lprun -f Fib Fib(100)

def fibloop(n):
  fib1back=1
  fib2back=1
  for i in range(2,n+1):
    fib=fib1back+fib2back
    fib2back=fib1back
    fib1back=fib
  return fib

# Commented out IPython magic to ensure Python compatibility.
# %lprun -f fibloop fibloop(30)

def fibdirect(n):
  from math import sqrt
  phi=1.6180339887
  return (phi**n-(1-phi)**n)/sqrt(5)

# Commented out IPython magic to ensure Python compatibility.
# %lprun -f fibdirect fibdirect(100)

# Commented out IPython magic to ensure Python compatibility.
pip install memory_profiler
# %load_ext memory_profiler
# %memit comp_series(2000)